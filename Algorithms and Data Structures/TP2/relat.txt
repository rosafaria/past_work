COMENTÁRIOS MAIS RELEVANTES:
Para a remoção das árvores foram tomadas duas opções: no caso das BST e AVL foi feita a remoção efectiva do nó (recursivamente - embora a recursão seja chamada no máximo 2 vezes, 1 para o nó a eliminar e outra para o nó mais à direita da sua sub-árvore esquerda); nos restantes casos (RB - dada a grande complexidade da operação - e Random) foi posto o contador a 0 e copiada a árvore periodicamente consoante o nº de nós até aí eliminados.
Embora nas primeiras submissões no Mooshak os métodos de procura e inserção fossem recursivos, esta abordagem foi posteriormente melhorada para métodos iterativos (submetida após o prazo nos dois primeiros casos). Foram também melhoradas as implementações em termos de POO.
As árvores AVL foram inicialmente submetidas com erros que apenas foram detectados após as medições para este relatório, sendo depois corrigidas e novamente submetidas.
Para a implementação das árvores aleatórias foi considerado o algoritmo dado nas aulas; não foi implementada uma treap.
Em todas as árvores cada nó tem um ponteiro para o pai. No caso das listas de saltos não há dupla ligação.


REFLEXÃO SOBRE RESULTADOS:
Primeiramente há que realçar que estes resultados foram obtidos com a última versão de cada implementação submetida no mooshak (mesmo que depois do prazo).
O primeiro (e mais visível) problema foi ao calcular o nº de travessias nas árvores AVL. Os resultados era extraordinariamente grandes, o que, após observação do código, mostrou que a solução usada para o cálculo da altura de cada nó não devia ter sido recursiva, já que bastava actualizar os nós envolvidos na rotação. Assim, os resultados apresentados na tabela não incluem esses cálculos, sendo essa função ignorada nas restantes questões deste relatório.
Observando o panorama geral vemos que, como esperado, as árvores binárias foram as árvores com mais atravessamentos, sendo óbvio que esta implementação não é de modo algum adequada para casos degenerados (T1_DO), em que se vê claramente que a performance é muito inferior à das restantes estruturas de dados. A Lista de Saltos tem resultados próximos quanto ao número de atravessamentos, excepto no caso degenerado, em que é claramente melhor.
Como esperado, podemos observar que as RBT têm sempre menos rotações que as AVL, mas mais atravessamentos que estas. Pode-se também observar uma grande proximidade entre estes resultados e o número de atravessamentos das Árvores Aleatórias (não tendo sido considerados os splits destas), o que era de esperar, dado que a aleatoriedade terá como efeito uma tendência ao equilíbrio da árvore.


COMPLEXIDADE ESPACIAL:
As estruturas dos nós nas diferentes árvores são semelhantes, tendo sempre a palavra e o contador, ponteiros para cada um dos filhos e para o pai. Nalguns casos criaram-se alguns atributos booleanos para facilitar a leitura do código (por exemplo, o atributo pLeft, que indica se o nó está à esquerda do pai) e para implementação da cor nas RB (red é true se o nó for vermelho). Foram também usados os inteiros necessários para cálculo da altura (AVL) e para contar o nº de nós abaixo (Aleatórias). A árvore em si terá n nós, pelo que a complexidade espacial da estrutura da árvore é O(n).
Em termos específicos de cada abordagem temos:
Árvores Binárias: para cada operação são usadas um nº constante de variáveis auxiliares para cada nó, dado que as operações são iterativas (à excepção da eliminação que, como mencionado anteriormente, é recursiva, mas tem no máximo 2 chamadas). É, por isso, O(n).
AVL: como mencionado anteriormente, será ignorada a função recursiva de cálculo da altura, dado que seria desnecessária. Assim sendo, e dado que as abordagens são semelhantes às binárias (iterativas e recursão na eliminação), serão também O(n). Se fosse considerado o método recursivo de cálculo de altura a complexidade espacial passaria a ser O(n^2), dado que cada vez que a função equilibrar é chamada, é também feito o cálculo das alturas.
RB: Do mesmo modo, as implementações são todas iterativas (incluindo a recoloração dos nós, com abordagem bottom-up), e semelhantes às anteriores, sendo igualmente O(n).
Árvores aleatórias: a implementação das árvores aleatórias é semelhante às anteriores em termos de iteratividade, sendo a recursão apenas usada no split da árvore (que não percorrerá o mesmo nó mais que uma vez), sendo também de O(n).
Em todos os métodos recursivos é sempre criado um número de fixo de variáveis auxiliares para cada chamada, e os nós são percorridos apenas uma vez, sendo sempre no máximo O(n), mesmo nesses métodos.

Quantos às listas de saltos, em cada elemento são armazenados, para além da palavra e respectivo contador, um array de ponteiros e um inteiro com o nº de ponteiros (para facilitar a leitura do código). Neste caso foi definido um nível máximo de níveis, sendo portanto O(m*n), ou seja, linear em relação ao número de elementos.


PARAMETRIZAÇÃO DAS LISTAS DE SALTOS:
Para esta estrutura foi escolhido como nível máximo o valor 15, pois o número máximo de entradas distintas para os inputs em questão era de 20000, e log2(20000) = 14,29, e portanto seria necessário o número de níveis imediatamente superior a log2(nº max de entradas distintas). O número de níveis de cada nó foi calculado pela fórmula log2(aleat), em que aleat é um número aleatório entre 0 e 1. Deste modo garante-se que a probabilidade de o número de níveis ser 1 é de 1/2, a probabilidade de ser 2 é de 1/4, ou seja, a probabilidade de ser n é de 1/2^n.


CONCLUSÕES:
*Binárias: Como esperado são as que têm mais atravessamentos, sendo óbvio no caso de um input degenerado (já ordenado) que é um modo de pesquisa nada eficiente, já que a árvore binária se torna uma lista duplamente ligada de apenas um nível. Não necessitam de guardar dados adicionais e são as mais simples de implementar.
*AVL: As árvores AVL são, em termos de atravessamento, melhores que as alternativas. Terão, no entanto, uma inserção mais demorada, pois a execução de uma rotação é uma tarefa pesada computacionalmente. O facto de ser equilibradas torna as pesquisas muito eficientes, e são facilmente implementáveis.
*VP: Nas árvores Vermelhas e Pretas encontram-se também menos atravessamentos que na maioria. O número de rotações é menor que o das AVL (logo a inserção tem menos custos), apesar de, no caso T1_DO (degenerado) tem pouco menos rotações e muito mais atravessamentos. Nesta árvore a eliminação é de tal modo complexa que não tem utilidade implementá-la (a complexidade de operações faria com que se perdesse a eficiência da árvore). Assim, uma implementação que ponha apenas o contador a 0 e faça, periodicamente, a cópia da árvore para uma nova ignorando os contadores nulos, é mais eficiente.
*Listas de Saltos: O caso em que se vê melhor a vantagem da lista de saltos é, sem sombra de dúvida, o caso T1_DO, já que a entrada ordenada de inputs é até mais vantajosa para este tipo de estrutura. Nos restantes casos tem performances semelhantes às das árvores binárias. A sua implementação é relativamente simples, dado que é na sua base uma lista ligada. A implementação estática não tem necessariamente desvantagens, já que ter um nó com um número excessivo de ponteiros a null é até menos vantajoso (caso dinâmico). Performance apenas será mais próxima das outras estruturas para inputs grandes.
*Árvores Aleatórias: Nestas estruturas pode-se observar uma performance semelhante às AVL em termos de atravessamento, o que é o pretendido em termos teóricos, já que a probabilidade de um nó ficar como raiz de uma sub-árvore vai aumentando à medida que se desce na árvore, tornando-a bastante equilibrada para muitos elementos de input, tendendo para o equilíbrio total.
